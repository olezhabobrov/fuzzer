interface T {
    val foo: String
}
abstract class A : T {
    override val foo: String = TODO()
}
fun javaClass()  {
val k:Any = TODO()
when (k) {
 true -> ArrayList()
 else -> J()
}
.foo
}
class J : A(), T